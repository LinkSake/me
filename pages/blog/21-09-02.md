---
tag: dev, docker, rails, articulos
date: 2021/09/02
autor: Luis Angel Ortega
title: "Docker + Rails: Una soluci√≥n para tus dolores de cabeza"
description: ¬øLos nuevos desarrolladores de tu equipo tardan semanas en poder correr el proyecto? ¬øHacer que el proyecto llegue a producci√≥n es una odisea? Tal vez Docker sea la soluci√≥n.
---

¬øHas llegado a pasar una semana solamente tratando de correr el proyecto al que te acabas de unir? ¬øO tu aplicaci√≥n no corre en producci√≥n como corr√≠a en local?  
Hay una multitud de factores que pueden contribuir esto, por ello [Docker](https://www.docker.com/) nos ofrece una soluci√≥n con la cual podemos tener un mayor control sobre estas variables a trav√©s de las computadoras que sean necesarias.  

Dicho esto, en este articulo veremos como falicitarnos la vida al tener toda nuestra aplicaci√≥n de Ruby on Rails corriendo sobre Docker; incluidas las bases de datos que sean necesarias.

## Prerequisitos

Para poder seguir esta gu√≠a necesitaras tener [Docker instalado](https://docs.docker.com/get-docker/) as√≠ como un proyecto el cual quieras *dockerizar*, si solamente quieres pr√°cticar puedes usar [este proyecto de ejemplo](https://github.com/LinkSake/docker-rails) el cual necesita una conexi√≥n a [Postgres](https://es.wikipedia.org/wiki/PostgreSQL) y a [Redis](https://es.wikipedia.org/wiki/Redis) para funcionar.

¬øEres impaciente? ¬°Puedes clonar [esta rama](https://github.com/LinkSake/docker-rails/tree/docker) del proyecto donde ya se encuentran los archivos necesarios para correr el projecto dentro de Docker!

## Primero viene el Dockerfile

Lo primero que haremos ser√° hacer una [imagen](https://docs.docker.com/get-started/overview/#docker-objects) personalizada para nuestro proyecto, as√≠ que crearemos un archivo en la ra√≠z del mismo llamado `Dockerfile`

```bash
touch Dockerfile
```

La primer linea de nuestro archivo definir√° la imagen de la cual nos basaremos, en este caso ser√° la [imagen oficial de Ruby](https://hub.docker.com/_/ruby), pero usaremos la versi√≥n de [Alpine](https://es.wikipedia.org/wiki/Alpine_Linux) para tener una imagen m√°s ligera como resultado.

```Dockerfile
FROM ruby:3.0.1-alpine
```

> ‚ö†Ô∏è Asegurate que la version de Ruby (ruby:X.X.X-alpine) sea la misma que en tu proyecto, o tendr√°s errores a la hora de tratar de construir la imagen. Puedes encontrar la versi√≥n que usa tu proyecto en tu Gemfile.

Despu√©s sigue la parte m√°s dificil de este Dockerfile, instalar la dependendencias necesarias para que funcione el proyecto; las que se muestran aqu√≠ son las que funcionan para nuestro [proyecto de ejemplo](https://github.com/LinkSake/docker-rails), que incluyen las necesarias para realizar una conexi√≥n con Postgres, pero tendr√°s que descubrir cuales son necesarias para tu proyecto.

```Dockerfile
FROM ruby:3.0.1-alpine

RUN apk add --update --no-cache --virtual run-dependencies \
build-base \
postgresql-client \
postgresql-dev \
yarn \
git \
tzdata \
libpq \
&& rm -rf /var/cache/apk/*
```

> Puedes esperar a construir la imagen (`docker build .`) para revisar el error que imprima Docker, con eso podr√°s ir averiguando que depenencias hacen falta üòâ  

La √∫ltima linea (`rm -rf /var/cache/apk/*`) borra los paquetes de las dependencias que acabamos de instalar, esto ahorrar√° espacio en la imagen.  

Lo siguiente que debemos de realizar es crear un directorio dentro del contenedor donde podamos copiar el c√≥digo de nuestra aplicaci√≥n para su ejecuci√≥n, eso lo haremos con el siguente comando dentro de nuestro Dockerfile.

```Dockerfile
FROM ruby:3.0.1-alpine

RUN apk add --update --no-cache  --virtual run-dependencies \
build-base \
postgresql-client \
postgresql-dev \
yarn \
git \
tzdata \
libpq \
&& rm -rf /var/cache/apk/*

WORKDIR /docker-rails
```

> ¬°Recuerda cambiar el `docker-rails` por el nombre de tu proyecto!

As√≠ como le dimos un hogar a tu proyecto dentro del contenedor que crearemos, las gemas del mismo necesitan una carpeta tambi√©n. Por ello, le informaremos a [bundler](https://bundler.io/es/) donde colocarlas a trav√©s de una variable de ambiente.

```Dockerfile
FROM ruby:3.0.1-alpine

RUN apk add --update --no-cache  --virtual run-dependencies \
build-base \
postgresql-client \
postgresql-dev \
yarn \
git \
tzdata \
libpq \
&& rm -rf /var/cache/apk/*

WORKDIR /docker-rails

ENV BUNDLE_PATH /gems
```

Y aunque ya instalamos las dependencias necesarias para correr Rails dentro del contenedor, tu proyecto necesitar√° algunas gemas y algunos paquetes de JavaScript para funcionar de manera correcta, vamos a encargarnos de eso de la siguiente manera.

```Dockerfile
FROM ruby:3.0.1-alpine

RUN apk add --update --no-cache  --virtual run-dependencies \
build-base \
postgresql-client \
postgresql-dev \
yarn \
git \
tzdata \
libpq \
&& rm -rf /var/cache/apk/*

WORKDIR /docker-rails

ENV BUNDLE_PATH /gems

COPY package.json yarn.lock /docker-rails/
RUN yarn install
COPY Gemfile Gemfile.lock /docker-rails/
RUN bundle install
```

Ahora que ya tenemos todo lo necesario para que funcione tu proyecto, vamos a copiar el c√≥digo al contenedor dentro de la que carpeta que creamos con el comando `WORKDIR`.

```Dockerfile
FROM ruby:3.0.1-alpine

RUN apk add --update --no-cache  --virtual run-dependencies \
build-base \
postgresql-client \
postgresql-dev \
yarn \
git \
tzdata \
libpq \
&& rm -rf /var/cache/apk/*

WORKDIR /docker-rails

ENV BUNDLE_PATH /gems

COPY package.json yarn.lock /docker-rails/
RUN yarn install
COPY Gemfile Gemfile.lock /docker-rails/
RUN bundle install

COPY . /docker-rails/
```

> ¬øPor qu√© copiamos primero los manifiestos (package.json, Gemfile, etc.) y despu√©s el resto del proyecto? Esto nos evita tener que reinstalar las dependencias (dado a que se quedan en cach√©) despu√©s de cambiar el c√≥digo base y reconstruir la imagen; de esta manera solo cuando cambien los manifiestos se volver√° a correr sus comandos de instalaci√≥n.

Finalmente le diremos a Docker que comando correr cuando iniciemos nuestro contenedor (`rails`), as√≠ como los argumentos de este (`s -b 0.0.0.0`) y que puerto exponer para que nosotros podamos accesar a nuestra aplicaci√≥n.

```Dockerfile
FROM ruby:3.0.1-alpine

RUN apk add --update --no-cache  --virtual run-dependencies \
build-base \
postgresql-client \
postgresql-dev \
yarn \
git \
tzdata \
libpq \
&& rm -rf /var/cache/apk/*

WORKDIR /docker-rails

ENV BUNDLE_PATH /gems

COPY package.json yarn.lock /docker-rails/
RUN yarn install
COPY Gemfile Gemfile.lock /docker-rails/
RUN bundle install

COPY . /docker-rails/

ENTRYPOINT ["bin/rails"]
CMD ["s", "-b", "0.0.0.0"]

EXPOSE 3000
```

> El puerto default sobre el que Rails corre es el 3000, pero si has designado otro puerto dentro de tu aplicaci√≥n asegurarte de exponerlo de manera correcta.

Y con esto tenemos listo nuestro Dockerfile, aunque estamos lejos de tener nuestra aplicaci√≥n lista. Si construyeramos nuestra imagen con `docker build .` y trataramos de correrla con `docker start docker-rails` nos encontrar√≠amos con un error, ya que Rails no encuentra las bases de datos que necesita para iniciar de manera correcta; pero pronto nos encargaremos de ello.

## Luego el docker-compose.yml

Para poder coordinar todos los servicios que necesitamos para el correcto funcionamiento de nuestra aplicaci√≥n (en este caso 2 bases de datos: Posgres y Redis) usaremos [docker-compose](https://docs.docker.com/compose/), esta √∫tilidad de Docker nos ayudar√° a crear multimples contenedores de diferentes imagenes, [conectarlos](https://docs.docker.com/compose/networking/), darles [variables de ambiente](https://docs.docker.com/compose/environment-variables/) e incluso [volumenes](https://docs.docker.com/storage/volumes/).

Empezaremos creando un archivo llamado `docker-compose.yml`.

```bash
touch docker-compose.yml
```

Y en su primera linea especificaremos que [versi√≥n](https://docs.docker.com/compose/compose-file/#compose-and-docker-compatibility-matrix) de la herramienta queremos usar, en este caso usaremos la m√°s reciente a la redacci√≥n de este articulo.

```yaml
version: '3.8'
```

Despu√©s indicaremos los servicios que queremos que corra docker-compose, esto lo haremos dentro de la etiqueta `services`. A cada servicio le daremos un nombre el cual ser√° importante cuando estemos configurando nuestra imagen as√≠ que asegurate de nombrarlo de una manera que haga sentido para ti. Vamos como primer ejemplo servicio de Posgres, al cual llamaremos *db*.

```yaml
version: '3.8'
services:
  db:
    image: postgres:latest
    container_name: docker-rails-db
    environment:
      - POSTGRES_DB=docker-rails-dev
      - POSTGRES_PASSWORD=password
    ports:
      - 5432:5432
    volumes:
      - 'dbdata:/var/lib/postgresql/data'
```

> Los archivos YAML son sensibles a la identaci√≥n, as√≠ que asegurate de tener todo en orden y andidado de forma correcta.

La etiqueta `db` es el nombre que le dimos al servicio y dentro de la cual especificaremos toda la configuraci√≥n del mismo.

Lo primero con lo que nos encontramos es `image` que tal como su nombre lo indica es el nombre de la imagen que queremos usar para ese servicio, en este caso es la imagen oficial de Posgres en su √∫ltima versi√≥n (puedes especificar una versi√≥n remplazando el `latest` por alguna otra versi√≥n v√°lida).

Despu√©s nos encontramos con `container_name`, que tambi√©n es autodescriptivo y el cual vendra √∫til a la hora de checar nuestros contendores con `docker ps`.

`enviroment` se refiere a las variables de ambiente, y si nos referimos a la documentaci√≥n de la imagen de [Docker de Posgres](https://hub.docker.com/_/postgres) podemos ver que la √∫nica variable obligatoria es `POSTGRES_PASSWORD` pero nosotros tambi√©n definiremos `POSTGRES_DB` para darle un nombre personalizado a la base de datos que crea la imagen por defecto.

> ‚ö†Ô∏è ¬°Asegurate de elegir una contrase√±a segura para la base de datos!

`ports` son los puertos que necesitaremos pasar de dentro del contenedor a nuestra maquina, los indicados en el archivo son los que por defecto usa Posgres.

Finalmente los `volumes` son la infomaci√≥n persistente que necesitaremos para no correr las migraciones cada vez que encendamos el contenedor, esto porque Docker borra todos los datos una vez que damos de baja la informaci√≥n, si quieres aprender m√°s sobre este tema te recomiendo [esta](https://docs.docker.com/storage/volumes/) secci√≥n de la documentaci√≥n.

Ahora, el siguiente servicio es el de Redis pero no ahondaremos mucho en el pues cuenta solo con un par de etiquetas las cuales ya hemos revisado, para m√°s informaci√≥n puedes visitar [la imagen oficial.](https://hub.docker.com/_/redis)

```yaml
version: '3.8'
services:
  db:
    image: postgres:latest
    container_name: docker-rails-db
    environment:
      - POSTGRES_DB=docker-rails-dev
      - POSTGRES_PASSWORD=password
    ports:
      - 5432:5432
    volumes:
      - 'dbdata:/var/lib/postgresql/data'
  redis:
    image: redis:latest
    container_name: docker-rails-redis
    ports:
      - 6379:6379
```

Nuestro √∫ltimo servicio lo llamaremos `web` y ser√° la imagen que hemos construido con nuestro `Dockerfile`.

```yaml
version: '3.8'
services:
  db:
    image: postgres:latest
    container_name: docker-rails-db
    environment:
      - POSTGRES_DB=docker-rails-dev
      - POSTGRES_PASSWORD=password
    ports:
      - 5432:5432
    volumes:
      - 'dbdata:/var/lib/postgresql/data'
  redis:
    image: redis:latest
    container_name: docker-rails-redis
    ports:
      - 6379:6379
  web:
    build: .
    image: docker-rails
    container_name: docker-rails-web
    ports:
      - 3000:3000
    depends_on:
      - db
      - redis
    environment:
      - POSTGRES_HOST=db
      - POSTGRES_USER=postgres
      - POSTGRES_PASSWORD=password
      - REDIS_URL=redis://redis:6379
```

La primer etiqueta nueva con la que nos topamos es `build`, la cual indica el directorio donde se encuentra nuestro Dockerfile; dado a que nuestro Dockerfile est√° en la ra√≠z solamente pondremos `.`; si tu Dockerfile no est√° en la ra√≠z o tiene otro nombre es recomendable que leas [esta](https://docs.docker.com/compose/compose-file/compose-file-v3/#build) secci√≥n de la documentaci√≥n para asegurarte que Compose lo encuentre.

La etiqueta `image` en este caso servir√° para nombrar la imagen que construir√° Compose, ya que al estar presente `build` no ir√° al repositorio a buscar una imagen preconstruida.

Por √∫ltimo, la etiqueta `depends_on` informar√° a Compose que no se debe de tratar de iniciar el contenedor hasta que est√©n creados los servicios `db` y `redis`, as√≠ como los conectar√° de manera interna para que nosotros podamos accesar a ellos mediante un URL (como se puede observar en la variable de ambiente de Redis) o por sus respectivas credenciales (como es el caso de Postgres), si quieres aprender como Docker maneja eso puedes leer sobre [Docker Network](https://docs.docker.com/compose/networking/).

Ahora que ya terminamos con los servicios, lo unico que debemos es listar los volumenes que usaremos y a los cuales [nombramos](https://docs.docker.com/compose/compose-file/compose-file-v3/#volumes) de la siguiente manera.

```yaml
version: '3.8'
services:
  db:
    image: postgres:latest
    container_name: docker-rails-db
    environment:
      - POSTGRES_DB=docker-rails-dev
      - POSTGRES_PASSWORD=password
    ports:
      - 5432:5432
    volumes:
      - 'dbdata:/var/lib/postgresql/data'
  redis:
    image: redis:latest
    container_name: docker-rails-redis
    ports:
      - 6379:6379
  web:
    build: .
    image: docker-rails
    container_name: docker-rails-web
    ports:
      - 3000:3000
    depends_on:
      - db
      - redis
    environment:
      - POSTGRES_HOST=db
      - POSTGRES_USER=postgres
      - POSTGRES_PASSWORD=password
      - REDIS_URL=redis://redis:6379
    volumes:
      - .:/app
volumes:
  dbdata:
```

¬°Y listo! Nuestro `docker-compose.yml` est√° listo, ahora solo falta un paso para empezar a crear nuestra aplicaci√≥n contenida en Docker.

## Ojos que no ven, .dockerignore que no siente

Muchas veces no queremos que ciertos archivos est√©n en nuestra imagen de Docker pues estos no son necesarios para su contrucci√≥n (o se generan en la misma) y solo terminan haciendo el proyecto m√°s grande de lo que necesita ser, como puede ser el caso de los `node_modules` y la carpeta `.git`.  
Para ahorrarnos este espacio crearemos un archivo llamado `.dockerignore` en la ra√≠z de nuestro proyecto y a√±adiremos estas dos carpetas:

```bash
echo ".git \n node_modules" >> .dockerignore
```

Para m√°s informaci√≥n sobre lo que puede contenener un archivo `.dockerignore` puedes consultar la [documentaci√≥n oficial de Docker](https://docs.docker.com/engine/reference/builder/#dockerignore-file)

## Unas bases de datos para llevar

Antes de correr el proyecto ser√° necesario crear la base de datos que Rails espera, y crearla es tan sencillo que se puede hacer en un solo comando.

```bash
docker-compose run web db:create
```

Este comando le dice a Docker que use la imagen (que construir√°) para correr un comando, en este caso `db:create`. Docker, con lo especificado en el `docker-compose.yml` sabe que como *web* depende de *db* tendr√° que correr primero la instancia de Postgres, por lo que la base de datos se crear√° en este contenedor.

> ¬øPor qu√© solamente `db:create` y no `rails db:create` o `rake db:create`? En nuestro `Dockerfile` dimos como punto de entrada el comando `rails`, por ello solo es necesario pasar los parametros. Si quisieramos efectuar otro comando dentro del contenedor esto tendr√≠a que ser a trav√©s de [docker exec](https://docs.docker.com/engine/reference/commandline/exec/).

## Nuestra aplicaci√≥n en un contenedor

Con la base de datos creada, solo queda un comando que corra los contenedores en [modo separado](https://docs.docker.com/compose/reference/up/) y podremos ver el fruto de nuestro trabajo.

```bash
docker-compose up -d
```

¬°Y listo! Ya podr√°s accesar a traves de tu navegador a [localhost:3000](http://localhost:3000/) y ver la p√°gina de bienvenida de Rails.

![Welcome to Rails!](https://dev-to-uploads.s3.amazonaws.com/uploads/articles/fiscat1lxr91qo1jnbaj.png)

## Conclusi√≥n

Puede que todo este proceso sea algo intimidante al principio, en especial si no sabes Docker, pero su resultado es un ambiente de desarrollo mucho m√°s sencillo para todos los involucrados en el proyecto, pues ahora solo con tener Docker instalado podr√°n iniciar a programar; sin mencionar los beneficios que esta tecnolog√≠a puede traer a tu ambiente de producci√≥n cuando se combina con Kubernetes o Docker Swarm.

Espero que te haya sido √∫til, cualquier cosa puedes [contactarme](https://luisangel.me/about#contacto) y responder√© lo m√°s pronto posible.

## Bibliograf√≠a

- [Docker Docs](https://docs.docker.com/samples/rails/)
- [Go Rails](https://gorails.com/episodes/docker-basics-for-gorails)
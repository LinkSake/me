---
tag: dev, docker, rails
date: 2021/09/02
autor: Luis Angel Ortega
title: "Docker + Rails: Una soluci√≥n para tus dolores de cabeza"
description: ¬øLos nuevos desarrolladores de tu equipo tardan semanas en poder correr el proyecto? ¬øHacer que el proyecto llegue a producci√≥n es una odisea? Tal vez Docker sea la soluci√≥n.
---

¬øHas llegado a pasar una semana solamente tratando de correr el proyecto al que te acabas de unir? ¬øO tu aplicaci√≥n no corre en producci√≥n como corr√≠a en local?  
Hay una multitud de factores que pueden contribuir esto, por ello [Docker](queesdockerpuntocom) nos ofrece una soluci√≥n con la cual podemos tener un mayor control sobre estas variables a trav√©s de las computadoras que sean necesarias.  

Dicho esto, en este articulo veremos como falicitarnos la vida al tener toda nuestra aplicaci√≥n de Ruby on Rails corriendo sobre Docker; incluidas las bases de datos que sean necesarias.

## Prerequisitos

Para poder seguir esta gu√≠a necesitaras tener [Docker instalado](instalardockerpuntocom) as√≠ como un proyecto el cual quieras *dockerizar*, si solamente quieres pr√°cticar puedes usar [este proyecto de ejemplo](github) el cual necesita una conexi√≥n a [Postgres](psql) y a [Redis](redis) para funcionar.

¬øEres impaciente? ¬°Puedes clonar [esta rama](github) del proyecto donde ya se encuentran los archivos necesarios para correr el projecto dentro de Docker!

## Primero viene el Dockerfile

Lo primero que haremos ser√° hacer una [imagen](queesunaimagendedockerpuntocom) personalizada para nuestro proyecto, as√≠ que crearemos un archivo en la ra√≠z del mismo llamado `Dockerfile`

```bash
touch Dockerfile
```

La primer linea de nuestro archivo definir√° la imagen de la cual nos basaremos, en este caso ser√° la [imagen oficial de Ruby](dockerhub), pero usaremos la versi√≥n de [Alpine]() para tener una imagen m√°s ligera como resultado.

```Dockerfile
FROM ruby:3.0.1-alpine
```

> ‚ö†Ô∏è Asegurate que la version de Ruby (ruby:X.X.X-alpine) sea la misma que en tu proyecto, o tendr√°s errores a la hora de tratar de construir la imagen. Puedes encontrar la versi√≥n que usa tu proyecto en tu Gemfile.

Despu√©s sigue la parte m√°s dificil de este Dockerfile, instalar la dependendencias necesarias para que funcione el proyecto; las que se muestran aqu√≠ son las que funcionan para nuestro [proyecto de ejemplo](github), que incluyen las necesarias para realizar una conexi√≥n con Postgres, pero tendr√°s que descubrir cuales son necesarias para tu proyecto.

```Dockerfile
FROM ruby:3.0.1-alpine

RUN apk add --update --no-cache --virtual run-dependencies \
build-base \
postgresql-client \
postgresql-dev \
yarn \
git \
tzdata \
libpq \
&& rm -rf /var/cache/apk/*
```

> Puedes esperar a construir la imagen (`docker build .`) para revisar el error que imprima Docker, con eso podr√°s ir averiguando que depenencias hacen falta üòâ  

La √∫ltima linea (`rm -rf /var/cache/apk/*`) borra los paquetes de las dependencias que acabamos de instalar, esto ahorrar√° espacio en la imagen.  

Lo siguiente que debemos de realizar es crear un directorio dentro del contenedor donde podamos copiar el c√≥digo de nuestra aplicaci√≥n para su ejecuci√≥n, eso lo haremos con el siguente comando dentro de nuestro Dockerfile.

```Dockerfile
FROM ruby:3.0.1-alpine

RUN apk add --update --no-cache  --virtual run-dependencies \
build-base \
postgresql-client \
postgresql-dev \
yarn \
git \
tzdata \
libpq \
&& rm -rf /var/cache/apk/*

WORKDIR /docker-rails
```

> ¬°Recuerda cambiar el `docker-rails` por el nombre de tu proyecto!

As√≠ como le dimos un hogar a tu proyecto dentro del contenedor que crearemos, las gemas del mismo necesitan una carpeta tambi√©n. Por ello, le informaremos a [bundler](bundler) donde colocarlas a trav√©s de una variable de ambiente.

```Dockerfile
FROM ruby:3.0.1-alpine

RUN apk add --update --no-cache  --virtual run-dependencies \
build-base \
postgresql-client \
postgresql-dev \
yarn \
git \
tzdata \
libpq \
&& rm -rf /var/cache/apk/*

WORKDIR /docker-rails

ENV BUNDLE_PATH /gems
```

Y aunque ya instalamos las dependencias necesarias para correr Rails dentro del contenedor, tu proyecto necesitar√° algunas gemas y algunos paquetes de JavaScript para funcionar de manera correcta, vamos a encargarnos de eso de la siguiente manera.

```Dockerfile
FROM ruby:3.0.1-alpine

RUN apk add --update --no-cache  --virtual run-dependencies \
build-base \
postgresql-client \
postgresql-dev \
yarn \
git \
tzdata \
libpq \
&& rm -rf /var/cache/apk/*

WORKDIR /docker-rails

ENV BUNDLE_PATH /gems

COPY package.json yarn.lock /docker-rails/
RUN yarn install
COPY Gemfile Gemfile.lock /docker-rails/
RUN bundle install
```

Ahora que ya tenemos todo lo necesario para que funcione tu proyecto, vamos a copiar el c√≥digo al contenedor dentro de la que carpeta que creamos con el comando `WORKDIR`.

```Dockerfile
FROM ruby:3.0.1-alpine

RUN apk add --update --no-cache  --virtual run-dependencies \
build-base \
postgresql-client \
postgresql-dev \
yarn \
git \
tzdata \
libpq \
&& rm -rf /var/cache/apk/*

WORKDIR /docker-rails

ENV BUNDLE_PATH /gems

COPY package.json yarn.lock /docker-rails/
RUN yarn install
COPY Gemfile Gemfile.lock /docker-rails/
RUN bundle install

COPY . /docker-rails/
```

> ¬øPor qu√© copiamos primero los manifiestos (package.json, Gemfile, etc.) y despu√©s el resto del proyecto? Esto nos evita tener que reinstalar las dependencias (dado a que se quedan en cach√©) despu√©s de cambiar el c√≥digo base y reconstruir la imagen; de esta manera solo cuando cambien los manifiestos se volver√° a correr sus comandos de instalaci√≥n.

Finalmente le diremos a Docker que comando correr cuando iniciemos nuestro contenedor (`rails`), as√≠ como los argumentos de este (`s -b 0.0.0.0`) y que puerto exponer para que nosotros podamos accesar a nuestra aplicaci√≥n.

```Dockerfile
FROM ruby:3.0.1-alpine

RUN apk add --update --no-cache  --virtual run-dependencies \
build-base \
postgresql-client \
postgresql-dev \
yarn \
git \
tzdata \
libpq \
&& rm -rf /var/cache/apk/*

WORKDIR /docker-rails

ENV BUNDLE_PATH /gems

COPY package.json yarn.lock /docker-rails/
RUN yarn install
COPY Gemfile Gemfile.lock /docker-rails/
RUN bundle install

COPY . /docker-rails/

ENTRYPOINT ["bin/rails"]
CMD ["s", "-b", "0.0.0.0"]

EXPOSE 3000
```

Y con esto tenemos listo nuestro Dockerfile, aunque estamos lejos de tener nuestra aplicaci√≥n lista. Si construyeramos nuestra imagen con `docker build .` y trataramos de correrla con `docker start docker-rails` nos encontrar√≠amos con un error, ya que Rails no encuentra las bases de datos que necesita para iniciar de manera correcta; pero pronto nos encargaremos de ello.

## Ojos que no ven, .dockerignore que no siente
